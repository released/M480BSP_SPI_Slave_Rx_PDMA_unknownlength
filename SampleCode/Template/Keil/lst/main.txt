; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DENABLE_SPI_SLAVE --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.ADC_InitChannel||, CODE, READONLY, ALIGN=2

                  ADC_InitChannel PROC
;;;291    
;;;292    void ADC_InitChannel(uint8_t ch)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;293    {
;;;294    	uint32_t ModuleMask = BIT0 ;		// use bit 0 as module ask
;;;295    	uint32_t ModuleNum = 0 ;			// use ch 0 as module num
;;;296    	uint16_t get_adc = 0;
;;;297    
;;;298        /* Set input mode as single-end, and Single mode*/
;;;299        EADC_Open(EADC, EADC_CTL_DIFFEN_SINGLE_END);
000004  4c1b              LDR      r4,|L1.116|
000006  4607              MOV      r7,r0                 ;293
000008  2600              MOVS     r6,#0                 ;295
00000a  2501              MOVS     r5,#1                 ;294
00000c  4631              MOV      r1,r6
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       EADC_Open
;;;300    
;;;301        EADC_SetExtendSampleTime(EADC, ch, 0x3F);
000014  223f              MOVS     r2,#0x3f
000016  4639              MOV      r1,r7
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       EADC_SetExtendSampleTime
;;;302    	
;;;303    	EADC_ConfigSampleModule(EADC, ModuleNum, EADC_ADINT0_TRIGGER, ch);
00001e  463b              MOV      r3,r7
000020  046a              LSLS     r2,r5,#17
000022  4631              MOV      r1,r6
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       EADC_ConfigSampleModule
;;;304    
;;;305        EADC_CLR_INT_FLAG(EADC, EADC_STATUS2_ADIF0_Msk);
00002a  2701              MOVS     r7,#1
00002c  f8c470f8          STR      r7,[r4,#0xf8]
;;;306    	
;;;307        EADC_ENABLE_INT(EADC, BIT0);
000030  6d20              LDR      r0,[r4,#0x50]
000032  f0400004          ORR      r0,r0,#4
000036  6520              STR      r0,[r4,#0x50]
;;;308        EADC_ENABLE_SAMPLE_MODULE_INT(EADC, 0, (ModuleMask));
000038  f8d400d0          LDR      r0,[r4,#0xd0]
00003c  f0400001          ORR      r0,r0,#1
000040  f8c400d0          STR      r0,[r4,#0xd0]
;;;309        NVIC_EnableIRQ(EADC00_IRQn);
000044  202a              MOVS     r0,#0x2a
000046  f7fffffe          BL       NVIC_EnableIRQ
;;;310    
;;;311    	set_flag(flag_ADC_Data_Ready , DISABLE);				
00004a  480b              LDR      r0,|L1.120|
00004c  68c1              LDR      r1,[r0,#0xc]  ; BitFlag
00004e  f0210102          BIC      r1,r1,#2
000052  60c1              STR      r1,[r0,#0xc]  ; BitFlag
;;;312    	EADC_START_CONV(EADC, (ModuleMask));						
000054  6567              STR      r7,[r4,#0x54]
                  |L1.86|
;;;313    	// while(is_flag_set(flag_ADC_Data_Ready) == DISABLE);
;;;314    	while(EADC_GET_DATA_VALID_FLAG(EADC, (ModuleMask)) != (ModuleMask));
000056  f8d400f4          LDR      r0,[r4,#0xf4]
00005a  f0000107          AND      r1,r0,#7
00005e  f8d400f0          LDR      r0,[r4,#0xf0]
000062  f361401f          BFI      r0,r1,#16,#16
000066  ea350000          BICS     r0,r5,r0
00006a  d1f4              BNE      |L1.86|
;;;315    	
;;;316    	get_adc = EADC_GET_CONV_DATA(EADC, ModuleNum);
00006c  f8540026          LDR      r0,[r4,r6,LSL #2]
;;;317    
;;;318    	#if 0	// debug
;;;319    	printf("%s : 0x%4X\r\n" , __FUNCTION__ , get_adc);
;;;320    	#endif
;;;321    
;;;322    	UNUSED(get_adc);
;;;323    }
000070  e8bd81f0          POP      {r4-r8,pc}
;;;324    
                          ENDP

                  |L1.116|
                          DCD      0x40043000
                  |L1.120|
                          DCD      ||.data||

                          AREA ||i.ADC_ReadChannel||, CODE, READONLY, ALIGN=2

                  ADC_ReadChannel PROC
;;;266    
;;;267    unsigned int ADC_ReadChannel(void)
000000  b530              PUSH     {r4,r5,lr}
;;;268    {
;;;269    	uint32_t ModuleMask = BIT0 ;		// use bit 0 as module ask
;;;270    	uint32_t ModuleNum = 0 ;			// use ch 0 as module num
;;;271    	uint16_t get_adc = 0;
;;;272    
;;;273        EADC_CLR_INT_FLAG(EADC, EADC_STATUS2_ADIF0_Msk);
000002  4812              LDR      r0,|L2.76|
000004  2401              MOVS     r4,#1                 ;269
000006  2300              MOVS     r3,#0                 ;270
000008  f8c040f8          STR      r4,[r0,#0xf8]
;;;274    	
;;;275        EADC_ENABLE_INT(EADC, BIT0);
00000c  6d01              LDR      r1,[r0,#0x50]
00000e  f0410104          ORR      r1,r1,#4
000012  6501              STR      r1,[r0,#0x50]
;;;276        EADC_ENABLE_SAMPLE_MODULE_INT(EADC, 0, (ModuleMask));
000014  f8d010d0          LDR      r1,[r0,#0xd0]
000018  f0410101          ORR      r1,r1,#1
00001c  f8c010d0          STR      r1,[r0,#0xd0]
;;;277    
;;;278    	set_flag(flag_ADC_Data_Ready , DISABLE);				
000020  490b              LDR      r1,|L2.80|
000022  68cd              LDR      r5,[r1,#0xc]  ; BitFlag
000024  f0250502          BIC      r5,r5,#2
000028  60cd              STR      r5,[r1,#0xc]  ; BitFlag
;;;279    	EADC_START_CONV(EADC, (ModuleMask));						
00002a  6544              STR      r4,[r0,#0x54]
                  |L2.44|
;;;280    	// while(is_flag_set(flag_ADC_Data_Ready) == DISABLE);
;;;281    	while(EADC_GET_DATA_VALID_FLAG(EADC, (ModuleMask)) != (ModuleMask));
00002c  f8d010f4          LDR      r1,[r0,#0xf4]
000030  f8d020f0          LDR      r2,[r0,#0xf0]
000034  f0010107          AND      r1,r1,#7
000038  f361421f          BFI      r2,r1,#16,#16
00003c  ea340102          BICS     r1,r4,r2
000040  d1f4              BNE      |L2.44|
;;;282    	
;;;283    	get_adc = EADC_GET_CONV_DATA(EADC, ModuleNum);
000042  f8500023          LDR      r0,[r0,r3,LSL #2]
000046  b280              UXTH     r0,r0
;;;284    
;;;285    	#if 0	// debug
;;;286    	printf("%s : 0x%4X\r\n" , __FUNCTION__ , get_adc);
;;;287    	#endif
;;;288    	
;;;289    	return get_adc;
;;;290    }
000048  bd30              POP      {r4,r5,pc}
;;;291    
                          ENDP

00004a  0000              DCW      0x0000
                  |L2.76|
                          DCD      0x40043000
                  |L2.80|
                          DCD      ||.data||

                          AREA ||i.CRC8||, CODE, READONLY, ALIGN=2

                  CRC8 PROC
;;;244    
;;;245    uint8_t CRC8( uint8_t *buf, uint16_t len)     
000000  b510              PUSH     {r4,lr}
;;;246    {               
000002  4602              MOV      r2,r0
;;;247    	uint8_t  crc=0;
000004  2000              MOVS     r0,#0
;;;248    
;;;249    	while ( len-- )     
;;;250    	{   
;;;251    		crc = CRC8TAB[crc^*buf]; 
000006  4c05              LDR      r4,|L3.28|
000008  e003              B        |L3.18|
                  |L3.10|
00000a  f8123b01          LDRB     r3,[r2],#1
00000e  4043              EORS     r3,r3,r0
000010  5ce0              LDRB     r0,[r4,r3]
                  |L3.18|
000012  1e49              SUBS     r1,r1,#1              ;249
000014  b289              UXTH     r1,r1                 ;249
000016  d2f8              BCS      |L3.10|
;;;252    
;;;253    		buf++;   
;;;254    	}     
;;;255    
;;;256    	return crc;     
;;;257    }  
000018  bd10              POP      {r4,pc}
;;;258    
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      ||.constdata||

                          AREA ||i.Custom_Init||, CODE, READONLY, ALIGN=2

                  Custom_Init PROC
;;;699    
;;;700    void Custom_Init(void)
000000  b510              PUSH     {r4,lr}
;;;701    {
;;;702    	SYS->GPH_MFPL = (SYS->GPH_MFPL & ~(SYS_GPH_MFPL_PH0MFP_Msk)) | (SYS_GPH_MFPL_PH0MFP_GPIO);
000002  f04f4080          MOV      r0,#0x40000000
000006  6e81              LDR      r1,[r0,#0x68]
000008  f021010f          BIC      r1,r1,#0xf
00000c  6681              STR      r1,[r0,#0x68]
;;;703    	SYS->GPH_MFPL = (SYS->GPH_MFPL & ~(SYS_GPH_MFPL_PH1MFP_Msk)) | (SYS_GPH_MFPL_PH1MFP_GPIO);
00000e  6e81              LDR      r1,[r0,#0x68]
000010  f02101f0          BIC      r1,r1,#0xf0
000014  6681              STR      r1,[r0,#0x68]
;;;704    	SYS->GPH_MFPL = (SYS->GPH_MFPL & ~(SYS_GPH_MFPL_PH2MFP_Msk)) | (SYS_GPH_MFPL_PH2MFP_GPIO);
000016  6e81              LDR      r1,[r0,#0x68]
000018  f4216170          BIC      r1,r1,#0xf00
00001c  6681              STR      r1,[r0,#0x68]
;;;705    
;;;706    	//EVM LED
;;;707    	GPIO_SetMode(PH,BIT0,GPIO_MODE_OUTPUT);
00001e  4c09              LDR      r4,|L4.68|
000020  2201              MOVS     r2,#1
000022  4611              MOV      r1,r2
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       GPIO_SetMode
;;;708    	GPIO_SetMode(PH,BIT1,GPIO_MODE_OUTPUT);
00002a  2201              MOVS     r2,#1
00002c  2102              MOVS     r1,#2
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       GPIO_SetMode
;;;709    	GPIO_SetMode(PH,BIT2,GPIO_MODE_OUTPUT);
000034  4620              MOV      r0,r4
000036  2201              MOVS     r2,#1
000038  e8bd4010          POP      {r4,lr}
00003c  2104              MOVS     r1,#4
00003e  f7ffbffe          B.W      GPIO_SetMode
;;;710    	
;;;711    }
;;;712    
                          ENDP

000042  0000              DCW      0x0000
                  |L4.68|
                          DCD      0x400041c0

                          AREA ||i.EADC00_IRQHandler||, CODE, READONLY, ALIGN=2

                  EADC00_IRQHandler PROC
;;;260    
;;;261    void EADC00_IRQHandler(void)
000000  4804              LDR      r0,|L5.20|
;;;262    {
;;;263        set_flag(flag_ADC_Data_Ready , ENABLE);
000002  68c1              LDR      r1,[r0,#0xc]  ; BitFlag
000004  f0410102          ORR      r1,r1,#2
000008  60c1              STR      r1,[r0,#0xc]  ; BitFlag
;;;264        EADC_CLR_INT_FLAG(EADC, EADC_STATUS2_ADIF0_Msk);      /* Clear the A/D ADINT0 interrupt flag */
00000a  4903              LDR      r1,|L5.24|
00000c  2001              MOVS     r0,#1
00000e  f8c100f8          STR      r0,[r1,#0xf8]
;;;265    }
000012  4770              BX       lr
;;;266    
                          ENDP

                  |L5.20|
                          DCD      ||.data||
                  |L5.24|
                          DCD      0x40043000

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.PDMA_IRQHandler||, CODE, READONLY, ALIGN=2

                  PDMA_IRQHandler PROC
;;;366    
;;;367    void PDMA_IRQHandler(void)
000000  4910              LDR      r1,|L7.68|
;;;368    {
;;;369        uint32_t status = PDMA_GET_INT_STATUS(PDMA);
000002  6808              LDR      r0,[r1,#0]
;;;370    	
;;;371        if (status & PDMA_INTSTS_ABTIF_Msk)   /* abort */
000004  07c2              LSLS     r2,r0,#31
000006  d003              BEQ      |L7.16|
;;;372        {
;;;373    		#if 1
;;;374            PDMA_CLR_ABORT_FLAG(PDMA, PDMA_GET_ABORT_STS(PDMA));
000008  1d08              ADDS     r0,r1,#4
00000a  6801              LDR      r1,[r0,#0]
00000c  6001              STR      r1,[r0,#0]
                  |L7.14|
;;;375    		#else
;;;376            if (PDMA_GET_ABORT_STS(PDMA) & (1 << SPI_SLAVE_TX_DMA_CH))
;;;377            {
;;;378    
;;;379            }
;;;380            PDMA_CLR_ABORT_FLAG(PDMA, (1 << SPI_SLAVE_TX_DMA_CH));
;;;381    
;;;382            if (PDMA_GET_ABORT_STS(PDMA) & (1 << SPI_SLAVE_RX_DMA_CH))
;;;383            {
;;;384    
;;;385            }
;;;386            PDMA_CLR_ABORT_FLAG(PDMA, (1 << SPI_SLAVE_RX_DMA_CH));
;;;387    		#endif
;;;388        }
;;;389        else if (status & PDMA_INTSTS_TDIF_Msk)     /* done */
;;;390        {
;;;391            if((PDMA_GET_TD_STS(PDMA) & SPI_SLAVE_OPENED_CH) == SPI_SLAVE_OPENED_CH)
;;;392            {
;;;393                /* Clear PDMA transfer done interrupt flag */
;;;394                PDMA_CLR_TD_FLAG(PDMA, SPI_SLAVE_OPENED_CH);
;;;395    
;;;396    			//insert process
;;;397    			SPI_DISABLE_RX_PDMA(BridgeSpiPortNum);			
;;;398            }        		
;;;399        }
;;;400        else if (status & (PDMA_INTSTS_REQTOF0_Msk | PDMA_INTSTS_REQTOF1_Msk))     /* Check the DMA time-out interrupt flag */
;;;401        {
;;;402            PDMA_CLR_TMOUT_FLAG(PDMA,SPI_SLAVE_TX_DMA_CH);
;;;403            PDMA_CLR_TMOUT_FLAG(PDMA,SPI_SLAVE_RX_DMA_CH);
;;;404        }
;;;405        else
;;;406        {
;;;407    
;;;408        }	
;;;409    }
00000e  4770              BX       lr
                  |L7.16|
000010  0782              LSLS     r2,r0,#30             ;389
000012  d50e              BPL      |L7.50|
000014  480b              LDR      r0,|L7.68|
000016  3008              ADDS     r0,r0,#8              ;391
000018  6801              LDR      r1,[r0,#0]            ;391
00001a  f3c13181          UBFX     r1,r1,#14,#2          ;391
00001e  2903              CMP      r1,#3                 ;391
000020  d1f5              BNE      |L7.14|
000022  0389              LSLS     r1,r1,#14             ;394
000024  6001              STR      r1,[r0,#0]            ;394
000026  4808              LDR      r0,|L7.72|
000028  68c1              LDR      r1,[r0,#0xc]          ;397
00002a  f0210102          BIC      r1,r1,#2              ;397
00002e  60c1              STR      r1,[r0,#0xc]          ;397
                  |L7.48|
000030  4770              BX       lr
                  |L7.50|
000032  f4107f40          TST      r0,#0x300             ;400
000036  d0fb              BEQ      |L7.48|
000038  f44f0080          MOV      r0,#0x400000          ;402
00003c  6008              STR      r0,[r1,#0]            ;402
00003e  0040              LSLS     r0,r0,#1              ;403
000040  6008              STR      r0,[r1,#0]            ;403
000042  4770              BX       lr
;;;410    
                          ENDP

                  |L7.68|
                          DCD      0x4000841c
                  |L7.72|
                          DCD      0x40061000

                          AREA ||i.SPI0_IRQHandler||, CODE, READONLY, ALIGN=2

                  SPI0_IRQHandler PROC
;;;454    
;;;455    void SPI0_IRQHandler(void)
000000  480c              LDR      r0,|L8.52|
;;;456    {
;;;457    
;;;458    	if (SPI_GET_SSINAIF_FLAG(BridgeSpiPortNum))
000002  6941              LDR      r1,[r0,#0x14]
000004  0709              LSLS     r1,r1,#28
000006  d513              BPL      |L8.48|
;;;459    	{
;;;460    //		SPI_ClearRxFIFO(BridgeSpiPortNum);
;;;461    //		SPI_ClearTxFIFO(BridgeSpiPortNum);
;;;462    
;;;463    		packetlen = PDMA_GET_TRANS_CNT(PDMA, SPI_SLAVE_RX_DMA_CH);
000008  490b              LDR      r1,|L8.56|
00000a  f8d110f0          LDR      r1,[r1,#0xf0]
00000e  0c0a              LSRS     r2,r1,#16
000010  490a              LDR      r1,|L8.60|
;;;464    		packetlen = (SPI_DATA_NUM - packetlen) -1;
000012  f1c2023f          RSB      r2,r2,#0x3f
000016  800a              STRH     r2,[r1,#0]
;;;465    		SPI_DISABLE_RX_PDMA(BridgeSpiPortNum);
000018  68c2              LDR      r2,[r0,#0xc]
00001a  f0220202          BIC      r2,r2,#2
00001e  60c2              STR      r2,[r0,#0xc]
;;;466    		
;;;467    		set_flag(flag_SPI_Slave_RX , ENABLE);
000020  68ca              LDR      r2,[r1,#0xc]  ; BitFlag
000022  f0420204          ORR      r2,r2,#4
000026  60ca              STR      r2,[r1,#0xc]  ; BitFlag
;;;468    
;;;469    		// #if 1	// debug
;;;470    		// printf("SPI RX = (data len:0x%2X/%2d(%2d),packet len:0x%2X,checksum :0x%2X)\r\n" ,packetlen-4,packetlen-4,g_au8SlaveRxBuffer[1],packetlen,g_au8SlaveRxBuffer[packetlen-2]);
;;;471    		// dump_buffer_hex(g_au8SlaveRxBuffer , SPI_DATA_NUM);
;;;472    		// #endif
;;;473    		
;;;474    		// SPI_Slave_Rx_PDMA_Enable();	
;;;475    
;;;476    		SPI_SET_SSINAIF_FLAG(BridgeSpiPortNum);			
000028  6941              LDR      r1,[r0,#0x14]
00002a  f0410108          ORR      r1,r1,#8
00002e  6141              STR      r1,[r0,#0x14]
                  |L8.48|
;;;477    	}
;;;478    }
000030  4770              BX       lr
;;;479    
                          ENDP

000032  0000              DCW      0x0000
                  |L8.52|
                          DCD      0x40061000
                  |L8.56|
                          DCD      0x40008000
                  |L8.60|
                          DCD      ||.data||

                          AREA ||i.SPI_Master_Init||, CODE, READONLY, ALIGN=2

                  SPI_Master_Init PROC
;;;526    */
;;;527    void SPI_Master_Init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;528    {
;;;529        SPI_Open(MasterSpiPortNum, SPI_MASTER, SPI_MODE_0, 8, SPI_TARGET_FREQ);
000002  4807              LDR      r0,|L9.32|
000004  4c07              LDR      r4,|L9.36|
000006  9000              STR      r0,[sp,#0]
000008  2308              MOVS     r3,#8
00000a  2204              MOVS     r2,#4
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       SPI_Open
;;;530    
;;;531        SPI_DisableAutoSS(MasterSpiPortNum);
000014  4620              MOV      r0,r4
000016  e8bd4038          POP      {r3-r5,lr}
00001a  f7ffbffe          B.W      SPI_DisableAutoSS
;;;532    }
;;;533    
                          ENDP

00001e  0000              DCW      0x0000
                  |L9.32|
                          DCD      0x000c3500
                  |L9.36|
                          DCD      0x40062000

                          AREA ||i.SPI_Master_TX||, CODE, READONLY, ALIGN=2

                  SPI_Master_TX PROC
;;;497    
;;;498    void SPI_Master_TX(SPI_T *spi , uint8_t *buffer , uint32_t len)
000000  b530              PUSH     {r4,r5,lr}
;;;499    {
;;;500    	uint32_t TxDataCount = 0;
;;;501    
;;;502        // /CS: active
;;;503        SPI_SET_SS_LOW(MasterSpiPortNum);
000002  4d0c              LDR      r5,|L10.52|
000004  2300              MOVS     r3,#0                 ;500
000006  68ac              LDR      r4,[r5,#8]
000008  f024040c          BIC      r4,r4,#0xc
00000c  f0440401          ORR      r4,r4,#1
000010  60ac              STR      r4,[r5,#8]
000012  e005              B        |L10.32|
                  |L10.20|
;;;504    
;;;505    	#if 0
;;;506        while ((SPI_GET_TX_FIFO_FULL_FLAG(spi) == 0)&& (TxDataCount < len))
;;;507        {
;;;508            SPI_WRITE_TX(spi, buffer[TxDataCount]);
;;;509    		TxDataCount++;
;;;510        }
;;;511    	#else
;;;512        while (TxDataCount < len)
;;;513        {
;;;514            SPI_WRITE_TX(spi, buffer[TxDataCount++]);
000014  5ccc              LDRB     r4,[r1,r3]
000016  6204              STR      r4,[r0,#0x20]
000018  1c5b              ADDS     r3,r3,#1
                  |L10.26|
;;;515    		while(SPI_IS_BUSY(spi));
00001a  6944              LDR      r4,[r0,#0x14]
00001c  07e4              LSLS     r4,r4,#31
00001e  d1fc              BNE      |L10.26|
                  |L10.32|
000020  4293              CMP      r3,r2                 ;512
000022  d3f7              BCC      |L10.20|
;;;516        }
;;;517    	#endif
;;;518    
;;;519    	// CS: de-active
;;;520        SPI_SET_SS_HIGH(MasterSpiPortNum);
000024  68a8              LDR      r0,[r5,#8]
000026  f0200008          BIC      r0,r0,#8
00002a  f0400005          ORR      r0,r0,#5
00002e  60a8              STR      r0,[r5,#8]
;;;521    }
000030  bd30              POP      {r4,r5,pc}
;;;522    
                          ENDP

000032  0000              DCW      0x0000
                  |L10.52|
                          DCD      0x40062000

                          AREA ||i.SPI_Slave_Init||, CODE, READONLY, ALIGN=2

                  SPI_Slave_Init PROC
;;;482    */
;;;483    void SPI_Slave_Init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;484    {
;;;485    	SYS_ResetModule(SPI0_RST);
000002  4810              LDR      r0,|L11.68|
000004  f7fffffe          BL       SYS_ResetModule
;;;486        SPI_Open(BridgeSpiPortNum, SPI_SLAVE, SPI_MODE_0, 8, (uint32_t)NULL);
000008  2000              MOVS     r0,#0
00000a  4c0f              LDR      r4,|L11.72|
00000c  2204              MOVS     r2,#4
00000e  9000              STR      r0,[sp,#0]
000010  2308              MOVS     r3,#8
000012  0411              LSLS     r1,r2,#16
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       SPI_Open
;;;487    
;;;488    	SPI_ClearRxFIFO(BridgeSpiPortNum);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       SPI_ClearRxFIFO
;;;489    
;;;490    	SPI_SetFIFO(BridgeSpiPortNum , 4 , 4);
000020  2204              MOVS     r2,#4
000022  4611              MOV      r1,r2
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       SPI_SetFIFO
;;;491    
;;;492    	SPI_EnableInt(BridgeSpiPortNum,SPI_SSINACT_INT_MASK );
00002a  2104              MOVS     r1,#4
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       SPI_EnableInt
;;;493        SPI_WRITE_TX(BridgeSpiPortNum, 0xFFFFFFFF);    /* Dummy Write to prevent TX under run */
000032  f04f31ff          MOV      r1,#0xffffffff
000036  6221              STR      r1,[r4,#0x20]
;;;494        NVIC_EnableIRQ(SPI0_IRQn);
000038  e8bd4038          POP      {r3-r5,lr}
00003c  2017              MOVS     r0,#0x17
00003e  f7ffbffe          B.W      NVIC_EnableIRQ
;;;495    }
;;;496    
                          ENDP

000042  0000              DCW      0x0000
                  |L11.68|
                          DCD      0x0400000d
                  |L11.72|
                          DCD      0x40061000

                          AREA ||i.SPI_Slave_Rx_PDMA_ClrBuffer||, CODE, READONLY, ALIGN=2

                  SPI_Slave_Rx_PDMA_ClrBuffer PROC
;;;411    
;;;412    void SPI_Slave_Rx_PDMA_ClrBuffer(void)
000000  2240              MOVS     r2,#0x40
;;;413    {
;;;414    	reset_buffer(g_au8SlaveRxBuffer , 0x00, SPI_DATA_NUM);
000002  2100              MOVS     r1,#0
000004  4801              LDR      r0,|L12.12|
000006  f7ffbffe          B.W      reset_buffer
;;;415    }
;;;416    
                          ENDP

00000a  0000              DCW      0x0000
                  |L12.12|
                          DCD      ||.bss||+0x40

                          AREA ||i.SPI_Slave_Rx_PDMA_Enable||, CODE, READONLY, ALIGN=2

                  SPI_Slave_Rx_PDMA_Enable PROC
;;;417    
;;;418    void SPI_Slave_Rx_PDMA_Enable(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;419    {
;;;420    	SPI_Slave_Rx_PDMA_ClrBuffer();
000002  f7fffffe          BL       SPI_Slave_Rx_PDMA_ClrBuffer
;;;421    
;;;422    	//RX
;;;423    	PDMA_SetTransferCnt(PDMA,SPI_SLAVE_RX_DMA_CH, PDMA_WIDTH_8, SPI_DATA_NUM);
000006  4d13              LDR      r5,|L13.84|
000008  2340              MOVS     r3,#0x40
00000a  2200              MOVS     r2,#0
00000c  210f              MOVS     r1,#0xf
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       PDMA_SetTransferCnt
;;;424    	PDMA_SetTransferAddr(PDMA,SPI_SLAVE_RX_DMA_CH, (uint32_t)&SPI0->RX, PDMA_SAR_FIX, (uint32_t)g_au8SlaveRxBuffer, PDMA_DAR_INC);		
000014  2400              MOVS     r4,#0
000016  4810              LDR      r0,|L13.88|
000018  e9cd0400          STRD     r0,r4,[sp,#0]
00001c  f44f7340          MOV      r3,#0x300
000020  4a0e              LDR      r2,|L13.92|
000022  210f              MOVS     r1,#0xf
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       PDMA_SetTransferAddr
;;;425    	/* Set request source; set basic mode. */
;;;426    	PDMA_SetTransferMode(PDMA,SPI_SLAVE_RX_DMA_CH, PDMA_SPI0_RX, FALSE, 0);
00002a  2300              MOVS     r3,#0
00002c  2217              MOVS     r2,#0x17
00002e  210f              MOVS     r1,#0xf
000030  4628              MOV      r0,r5
000032  9400              STR      r4,[sp,#0]
000034  f7fffffe          BL       PDMA_SetTransferMode
;;;427    	SPI_TRIGGER_RX_PDMA(SPI0);	
000038  4908              LDR      r1,|L13.92|
00003a  3930              SUBS     r1,r1,#0x30
00003c  68c8              LDR      r0,[r1,#0xc]
00003e  f0400002          ORR      r0,r0,#2
000042  60c8              STR      r0,[r1,#0xc]
;;;428    
;;;429    	PDMA_EnableInt(PDMA, SPI_SLAVE_RX_DMA_CH, PDMA_INT_TRANS_DONE);
000044  b002              ADD      sp,sp,#8
000046  4628              MOV      r0,r5
000048  e8bd4070          POP      {r4-r6,lr}
00004c  2200              MOVS     r2,#0
00004e  210f              MOVS     r1,#0xf
000050  f7ffbffe          B.W      PDMA_EnableInt
;;;430    }
;;;431    
                          ENDP

                  |L13.84|
                          DCD      0x40008000
                  |L13.88|
                          DCD      ||.bss||+0x40
                  |L13.92|
                          DCD      0x40061030

                          AREA ||i.SPI_Slave_Rx_PDMA_Init||, CODE, READONLY, ALIGN=2

                  SPI_Slave_Rx_PDMA_Init PROC
;;;431    
;;;432    void SPI_Slave_Rx_PDMA_Init(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;433    {
;;;434    	SPI_Slave_Rx_PDMA_ClrBuffer();
000002  f7fffffe          BL       SPI_Slave_Rx_PDMA_ClrBuffer
;;;435    	
;;;436        PDMA_Open(PDMA, SPI_SLAVE_OPENED_CH);
000006  4c1d              LDR      r4,|L14.124|
000008  f44f4140          MOV      r1,#0xc000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       PDMA_Open
;;;437    
;;;438    	//RX
;;;439        PDMA_SetTransferCnt(PDMA,SPI_SLAVE_RX_DMA_CH, PDMA_WIDTH_8, SPI_DATA_NUM);
000012  2340              MOVS     r3,#0x40
000014  2200              MOVS     r2,#0
000016  210f              MOVS     r1,#0xf
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       PDMA_SetTransferCnt
;;;440        /* Set source/destination address and attributes */
;;;441        PDMA_SetTransferAddr(PDMA,SPI_SLAVE_RX_DMA_CH, (uint32_t)&SPI0->RX, PDMA_SAR_FIX, (uint32_t)g_au8SlaveRxBuffer, PDMA_DAR_INC);
00001e  2500              MOVS     r5,#0
000020  4817              LDR      r0,|L14.128|
000022  e9cd0500          STRD     r0,r5,[sp,#0]
000026  f44f7340          MOV      r3,#0x300
00002a  4a16              LDR      r2,|L14.132|
00002c  210f              MOVS     r1,#0xf
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       PDMA_SetTransferAddr
;;;442        /* Set request source; set basic mode. */
;;;443        PDMA_SetTransferMode(PDMA,SPI_SLAVE_RX_DMA_CH, PDMA_SPI0_RX, FALSE, 0);
000034  2300              MOVS     r3,#0
000036  2217              MOVS     r2,#0x17
000038  210f              MOVS     r1,#0xf
00003a  4620              MOV      r0,r4
00003c  9500              STR      r5,[sp,#0]
00003e  f7fffffe          BL       PDMA_SetTransferMode
;;;444        /* Single request type. SPI only support PDMA single request type. */
;;;445        PDMA_SetBurstType(PDMA,SPI_SLAVE_RX_DMA_CH, PDMA_REQ_SINGLE, 0);
000042  2300              MOVS     r3,#0
000044  2204              MOVS     r2,#4
000046  210f              MOVS     r1,#0xf
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       PDMA_SetBurstType
;;;446        /* Disable table interrupt */
;;;447        PDMA->DSCT[SPI_SLAVE_RX_DMA_CH].CTL |= PDMA_DSCT_CTL_TBINTDIS_Msk;
00004e  f8d400f0          LDR      r0,[r4,#0xf0]
000052  f0400080          ORR      r0,r0,#0x80
000056  f8c400f0          STR      r0,[r4,#0xf0]
;;;448    
;;;449        SPI_TRIGGER_RX_PDMA(BridgeSpiPortNum);
00005a  480a              LDR      r0,|L14.132|
00005c  3830              SUBS     r0,r0,#0x30
00005e  68c1              LDR      r1,[r0,#0xc]
000060  f0410102          ORR      r1,r1,#2
000064  60c1              STR      r1,[r0,#0xc]
;;;450    
;;;451        PDMA_EnableInt(PDMA, SPI_SLAVE_RX_DMA_CH, PDMA_INT_TRANS_DONE);
000066  2200              MOVS     r2,#0
000068  210f              MOVS     r1,#0xf
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       PDMA_EnableInt
;;;452        NVIC_EnableIRQ(PDMA_IRQn);		
000070  e8bd407c          POP      {r2-r6,lr}
000074  2028              MOVS     r0,#0x28
000076  f7ffbffe          B.W      NVIC_EnableIRQ
;;;453    }
;;;454    
                          ENDP

00007a  0000              DCW      0x0000
                  |L14.124|
                          DCD      0x40008000
                  |L14.128|
                          DCD      ||.bss||+0x40
                  |L14.132|
                          DCD      0x40061030

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;712    
;;;713    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  0784              LSLS     r4,r0,#30
000006  2116              MOVS     r1,#0x16
000008  2288              MOVS     r2,#0x88
                  |L15.10|
00000a  f8c40100          STR      r0,[r4,#0x100]
00000e  f8c41100          STR      r1,[r4,#0x100]
000012  f8c42100          STR      r2,[r4,#0x100]
000016  f8d43100          LDR      r3,[r4,#0x100]
00001a  2b00              CMP      r3,#0
00001c  d0f5              BEQ      |L15.10|
;;;714    {
;;;715        /* Unlock protected registers */
;;;716        SYS_UnlockReg();
;;;717    
;;;718        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;719        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
00001e  f04f2540          MOV      r5,#0x40004000
000022  f8d50140          LDR      r0,[r5,#0x140]
000026  f02000f0          BIC      r0,r0,#0xf0
00002a  f8c50140          STR      r0,[r5,#0x140]
;;;720    
;;;721        CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
00002e  2004              MOVS     r0,#4
000030  f7fffffe          BL       CLK_EnableXtalRC
;;;722        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000034  2010              MOVS     r0,#0x10
000036  f7fffffe          BL       CLK_WaitClockReady
;;;723    
;;;724    //    CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
;;;725    //    CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;726    
;;;727    //    CLK_EnableXtalRC(CLK_PWRCTL_LIRCEN_Msk);
;;;728    //    CLK_WaitClockReady(CLK_STATUS_LIRCSTB_Msk);
;;;729    
;;;730    //    CLK_EnableXtalRC(CLK_PWRCTL_LXTEN_Msk);
;;;731    //    CLK_WaitClockReady(CLK_STATUS_LXTSTB_Msk);
;;;732    
;;;733        /* Set core clock as PLL_CLOCK from PLL */
;;;734        CLK_SetCoreClock(FREQ_192MHZ);
00003a  4842              LDR      r0,|L15.324|
00003c  f7fffffe          BL       CLK_SetCoreClock
;;;735        /* Set PCLK0/PCLK1 to HCLK/2 */
;;;736        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);
000040  2011              MOVS     r0,#0x11
000042  f8c40234          STR      r0,[r4,#0x234]
;;;737    
;;;738        /* Enable UART clock */
;;;739        CLK_EnableModuleClock(UART0_MODULE);
000046  4e40              LDR      r6,|L15.328|
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       CLK_EnableModuleClock
;;;740        /* Select UART clock source from HXT */
;;;741        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HIRC, CLK_CLKDIV0_UART0(1));
00004e  2200              MOVS     r2,#0
000050  f04f7140          MOV      r1,#0x3000000
000054  4630              MOV      r0,r6
000056  f7fffffe          BL       CLK_SetModuleClock
;;;742    
;;;743        CLK_SetModuleClock(SPI0_MODULE, CLK_CLKSEL2_SPI0SEL_PCLK1, MODULE_NoMsk);
00005a  4e3c              LDR      r6,|L15.332|
00005c  2200              MOVS     r2,#0
00005e  2120              MOVS     r1,#0x20
000060  4630              MOV      r0,r6
000062  f7fffffe          BL       CLK_SetModuleClock
;;;744        CLK_EnableModuleClock(SPI0_MODULE);
000066  4630              MOV      r0,r6
000068  f7fffffe          BL       CLK_EnableModuleClock
;;;745    
;;;746        CLK_SetModuleClock(SPI1_MODULE, CLK_CLKSEL2_SPI1SEL_PCLK0, MODULE_NoMsk);
00006c  4e38              LDR      r6,|L15.336|
00006e  2200              MOVS     r2,#0
000070  2180              MOVS     r1,#0x80
000072  4630              MOV      r0,r6
000074  f7fffffe          BL       CLK_SetModuleClock
;;;747        CLK_EnableModuleClock(SPI1_MODULE);	
000078  4630              MOV      r0,r6
00007a  f7fffffe          BL       CLK_EnableModuleClock
;;;748    
;;;749        /* Enable EADC module clock */
;;;750        CLK_EnableModuleClock(EADC_MODULE);
00007e  4e35              LDR      r6,|L15.340|
000080  4630              MOV      r0,r6
000082  f7fffffe          BL       CLK_EnableModuleClock
;;;751    
;;;752        /* EADC clock source is 96MHz, set divider to 8, EADC clock is 96/8 MHz */
;;;753        CLK_SetModuleClock(EADC_MODULE, 0, CLK_CLKDIV0_EADC(8));	
000086  f44f22e0          MOV      r2,#0x70000
00008a  2100              MOVS     r1,#0
00008c  4630              MOV      r0,r6
00008e  f7fffffe          BL       CLK_SetModuleClock
;;;754    
;;;755       CLK_EnableModuleClock(PDMA_MODULE);
000092  2001              MOVS     r0,#1
000094  f7fffffe          BL       CLK_EnableModuleClock
;;;756    
;;;757        CLK_EnableModuleClock(TMR1_MODULE);
000098  4e2f              LDR      r6,|L15.344|
00009a  4630              MOV      r0,r6
00009c  f7fffffe          BL       CLK_EnableModuleClock
;;;758        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HIRC, 0);
0000a0  2200              MOVS     r2,#0
0000a2  f44f41e0          MOV      r1,#0x7000
0000a6  4630              MOV      r0,r6
0000a8  f7fffffe          BL       CLK_SetModuleClock
;;;759    	
;;;760        /* Update System Core Clock */
;;;761        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;762        SystemCoreClockUpdate();
0000ac  f7fffffe          BL       SystemCoreClockUpdate
;;;763    
;;;764        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;765        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
0000b0  6be0              LDR      r0,[r4,#0x3c]
0000b2  f420007f          BIC      r0,r0,#0xff0000
0000b6  63e0              STR      r0,[r4,#0x3c]
;;;766        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
0000b8  6be0              LDR      r0,[r4,#0x3c]
0000ba  f44000cc          ORR      r0,r0,#0x660000
0000be  63e0              STR      r0,[r4,#0x3c]
;;;767    
;;;768    	/*
;;;769    		SPI slave SPI0 : PA0(MOSI)/PA1(MISO)/PA2(CLK)/PA3(SS)
;;;770    		SPI master SPI1 : PC0(SS)/PC1(CLK)/PC2(MOSI)/PC3(MISO)
;;;771    	*/
;;;772    
;;;773        /* Setup SPI0 multi-function pins */
;;;774        SYS->GPA_MFPL &= ~(SYS_GPA_MFPL_PA0MFP_Msk | SYS_GPA_MFPL_PA1MFP_Msk | SYS_GPA_MFPL_PA2MFP_Msk | SYS_GPA_MFPL_PA3MFP_Msk);
0000c0  6b20              LDR      r0,[r4,#0x30]
0000c2  f36f000f          BFC      r0,#0,#16
0000c6  6320              STR      r0,[r4,#0x30]
;;;775        SYS->GPA_MFPL |= (SYS_GPA_MFPL_PA0MFP_SPI0_MOSI | SYS_GPA_MFPL_PA1MFP_SPI0_MISO | SYS_GPA_MFPL_PA2MFP_SPI0_CLK | SYS_GPA_MFPL_PA3MFP_SPI0_SS);	
0000c8  6b20              LDR      r0,[r4,#0x30]
0000ca  f2444144          MOV      r1,#0x4444
0000ce  4308              ORRS     r0,r0,r1
0000d0  6320              STR      r0,[r4,#0x30]
;;;776    
;;;777        /* Enable SPI0 clock pin (PA2) schmitt trigger */
;;;778        PA->SMTEN |= GPIO_SMTEN_SMTEN2_Msk;
0000d2  6a68              LDR      r0,[r5,#0x24]
0000d4  f0400004          ORR      r0,r0,#4
0000d8  6268              STR      r0,[r5,#0x24]
;;;779    
;;;780        /* Enable SPI0 I/O high slew rate */
;;;781        GPIO_SetSlewCtl(PA, 0xF, GPIO_SLEWCTL_HIGH);
0000da  2201              MOVS     r2,#1
0000dc  210f              MOVS     r1,#0xf
0000de  4628              MOV      r0,r5
0000e0  f7fffffe          BL       GPIO_SetSlewCtl
;;;782    
;;;783        /* Setup SPI1 multi-function pins */
;;;784        SYS->GPC_MFPL &= ~(SYS_GPC_MFPL_PC0MFP_Msk | SYS_GPC_MFPL_PC1MFP_Msk | SYS_GPC_MFPL_PC2MFP_Msk | SYS_GPC_MFPL_PC3MFP_Msk);
0000e4  6c20              LDR      r0,[r4,#0x40]
0000e6  f36f000f          BFC      r0,#0,#16
0000ea  6420              STR      r0,[r4,#0x40]
;;;785        SYS->GPC_MFPL |= (SYS_GPC_MFPL_PC0MFP_SPI1_SS | SYS_GPC_MFPL_PC1MFP_SPI1_CLK | SYS_GPC_MFPL_PC2MFP_SPI1_MOSI| SYS_GPC_MFPL_PC3MFP_SPI1_MISO);	
0000ec  6c20              LDR      r0,[r4,#0x40]
0000ee  f2477177          MOV      r1,#0x7777
0000f2  4308              ORRS     r0,r0,r1
0000f4  6420              STR      r0,[r4,#0x40]
;;;786    
;;;787        /* Enable SPI1 clock pin (PC1) schmitt trigger */
;;;788        PC->SMTEN |= GPIO_SMTEN_SMTEN1_Msk;
0000f6  f8550fa4          LDR      r0,[r5,#0xa4]!
0000fa  f0400002          ORR      r0,r0,#2
0000fe  f8450964          STR      r0,[r5],#-0x64
;;;789    
;;;790        /* Enable SPI1 I/O high slew rate */
;;;791        GPIO_SetSlewCtl(PC, 0xF, GPIO_SLEWCTL_HIGH);	
000102  2201              MOVS     r2,#1
000104  210f              MOVS     r1,#0xf
000106  4815              LDR      r0,|L15.348|
000108  f7fffffe          BL       GPIO_SetSlewCtl
;;;792    
;;;793        PB->MODE &= ~(GPIO_MODE_MODE14_Msk);
00010c  6828              LDR      r0,[r5,#0]
00010e  f0205040          BIC      r0,r0,#0x30000000
000112  6028              STR      r0,[r5,#0]
;;;794    
;;;795        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB14MFP_Msk);
000114  6be0              LDR      r0,[r4,#0x3c]
000116  f0206070          BIC      r0,r0,#0xf000000
00011a  63e0              STR      r0,[r4,#0x3c]
;;;796        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB14MFP_EADC0_CH14);
00011c  6be0              LDR      r0,[r4,#0x3c]
00011e  f0407080          ORR      r0,r0,#0x1000000
000122  63e0              STR      r0,[r4,#0x3c]
;;;797    
;;;798        /* Disable the GPB0 - GPB3 digital input path to avoid the leakage current. */
;;;799        GPIO_DISABLE_DIGITAL_PATH(PB, BIT14);
000124  6868              LDR      r0,[r5,#4]
000126  f0404080          ORR      r0,r0,#0x40000000
00012a  6068              STR      r0,[r5,#4]
;;;800    
;;;801        /* Enable temperature sensor */
;;;802        SYS->IVSCTL |= SYS_IVSCTL_VTEMPEN_Msk;
00012c  69e0              LDR      r0,[r4,#0x1c]
00012e  f0400001          ORR      r0,r0,#1
000132  61e0              STR      r0,[r4,#0x1c]
;;;803    
;;;804        /* Set reference voltage to external pin (3.3V) */
;;;805        SYS_SetVRef(SYS_VREFCTL_VREF_PIN);	
000134  2000              MOVS     r0,#0
000136  f7fffffe          BL       SYS_SetVRef
00013a  2000              MOVS     r0,#0
00013c  f8c40100          STR      r0,[r4,#0x100]
;;;806    	
;;;807        /* Lock protected registers */
;;;808        SYS_LockReg();
;;;809    }
000140  bd70              POP      {r4-r6,pc}
;;;810    
                          ENDP

000142  0000              DCW      0x0000
                  |L15.324|
                          DCD      0x0b71b000
                  |L15.328|
                          DCD      0x57803d10
                  |L15.332|
                          DCD      0x6640000d
                  |L15.336|
                          DCD      0x6660000e
                  |L15.340|
                          DCD      0x4003fe1c
                  |L15.344|
                          DCD      0x5ec00003
                  |L15.348|
                          DCD      0x40004080

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;617    
;;;618    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;619    {
;;;620        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L16.44|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;621        TIMER_EnableInt(TIMER1);
;;;622        NVIC_EnableIRQ(TMR1_IRQn);	
00001a  2021              MOVS     r0,#0x21
00001c  f7fffffe          BL       NVIC_EnableIRQ
000020  6820              LDR      r0,[r4,#0]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  6020              STR      r0,[r4,#0]
;;;623        TIMER_Start(TIMER1);
;;;624    }
000028  bd10              POP      {r4,pc}
;;;625    
                          ENDP

00002a  0000              DCW      0x0000
                  |L16.44|
                          DCD      0x40050100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;594    
;;;595    void TMR1_IRQHandler(void)
000000  480d              LDR      r0,|L17.56|
;;;596    {
000002  b500              PUSH     {lr}
000004  6881              LDR      r1,[r0,#8]
000006  f3c10100          UBFX     r1,r1,#0,#1
00000a  2900              CMP      r1,#0
00000c  d012              BEQ      |L17.52|
00000e  2101              MOVS     r1,#1
000010  6081              STR      r1,[r0,#8]
;;;597    	// static uint32_t LOG = 0;
;;;598    	
;;;599        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;600        {
;;;601            TIMER_ClearIntFlag(TIMER1);
;;;602    		tick_counter();
000012  f7fffffe          BL       tick_counter
000016  4a09              LDR      r2,|L17.60|
000018  6910              LDR      r0,[r2,#0x10]  ; counter_tick
;;;603    
;;;604    		if ((get_tick() % 1000) == 0)
00001a  f44f717a          MOV      r1,#0x3e8
00001e  fbb0f3f1          UDIV     r3,r0,r1
000022  fb010013          MLS      r0,r1,r3,r0
000026  b920              CBNZ     r0,|L17.50|
;;;605    		{
;;;606    			// printf("%s : %4d\r\n",__FUNCTION__,LOG++);
;;;607    			PH0 ^= 1;
000028  4805              LDR      r0,|L17.64|
00002a  6801              LDR      r1,[r0,#0]
00002c  f0810101          EOR      r1,r1,#1
000030  6001              STR      r1,[r0,#0]
                  |L17.50|
000032  6910              LDR      r0,[r2,#0x10]  ; counter_tick
                  |L17.52|
;;;608    		}
;;;609    
;;;610    		if ((get_tick() % 50) == 0)
;;;611    		{
;;;612    
;;;613    		}	
;;;614        }
;;;615    }
000034  bd00              POP      {pc}
;;;616    
                          ENDP

000036  0000              DCW      0x0000
                  |L17.56|
                          DCD      0x40050100
                  |L17.60|
                          DCD      ||.data||
                  |L17.64|
                          DCD      0x400049c0

                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART0_IRQHandler PROC
;;;653    
;;;654    void UART0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;655    {
;;;656        if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RDAINT_Msk | UART_INTSTS_RXTOINT_Msk))     /* UART receive data available flag */
000002  4c0b              LDR      r4,|L18.48|
000004  69e0              LDR      r0,[r4,#0x1c]
000006  f4105f88          TST      r0,#0x1100
00000a  d102              BNE      |L18.18|
00000c  e004              B        |L18.24|
                  |L18.14|
;;;657        {
;;;658            while(UART_GET_RX_EMPTY(UART0) == 0)
;;;659            {
;;;660    			UARTx_Process();
00000e  f7fffffe          BL       UARTx_Process
                  |L18.18|
000012  69a1              LDR      r1,[r4,#0x18]         ;658
000014  0449              LSLS     r1,r1,#17             ;658
000016  d5fa              BPL      |L18.14|
                  |L18.24|
;;;661            }
;;;662        }
;;;663    
;;;664        if(UART0->FIFOSTS & (UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk | UART_FIFOSTS_RXOVIF_Msk))
000018  69a1              LDR      r1,[r4,#0x18]
00001a  4620              MOV      r0,r4
00001c  f0110f71          TST      r1,#0x71
000020  d005              BEQ      |L18.46|
;;;665        {
;;;666            UART_ClearIntFlag(UART0, (UART_INTSTS_RLSINT_Msk| UART_INTSTS_BUFERRINT_Msk));
000022  e8bd4010          POP      {r4,lr}
000026  f44f5110          MOV      r1,#0x2400
00002a  f7ffbffe          B.W      UART_ClearIntFlag
                  |L18.46|
;;;667        }	
;;;668    }
00002e  bd10              POP      {r4,pc}
;;;669    
                          ENDP

                  |L18.48|
                          DCD      0x40070000

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;669    
;;;670    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;671    {
;;;672        SYS_ResetModule(UART0_RST);
000002  481e              LDR      r0,|L19.124|
000004  f7fffffe          BL       SYS_ResetModule
;;;673    
;;;674        /* Configure UART0 and set UART0 baud rate */
;;;675        UART_Open(UART0, 115200);
000008  4c1d              LDR      r4,|L19.128|
00000a  f44f31e1          MOV      r1,#0x1c200
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;676    
;;;677    	/* Set UART receive time-out */
;;;678    	UART_SetTimeoutCnt(UART0, 20);
000014  2114              MOVS     r1,#0x14
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;679    
;;;680    	UART0->FIFO &= ~UART_FIFO_RFITL_4BYTES;
00001c  68a0              LDR      r0,[r4,#8]
00001e  f0200010          BIC      r0,r0,#0x10
000022  60a0              STR      r0,[r4,#8]
;;;681    	UART0->FIFO |= UART_FIFO_RFITL_8BYTES;
000024  68a0              LDR      r0,[r4,#8]
000026  f0400020          ORR      r0,r0,#0x20
00002a  60a0              STR      r0,[r4,#8]
;;;682    
;;;683    	/* Enable UART Interrupt - */
;;;684    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_TOCNTEN_Msk | UART_INTEN_RXTOIEN_Msk);
00002c  6860              LDR      r0,[r4,#4]
00002e  f6400111          MOV      r1,#0x811
000032  4308              ORRS     r0,r0,r1
000034  6060              STR      r0,[r4,#4]
;;;685    	
;;;686    	NVIC_EnableIRQ(UART0_IRQn);
000036  2024              MOVS     r0,#0x24
000038  f7fffffe          BL       NVIC_EnableIRQ
;;;687    
;;;688    	#if (_debug_log_UART_ == 1)	//debug
;;;689    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00003c  f7fffffe          BL       CLK_GetCPUFreq
000040  4601              MOV      r1,r0
000042  a010              ADR      r0,|L19.132|
000044  f7fffffe          BL       __2printf
;;;690    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
000048  f7fffffe          BL       CLK_GetHXTFreq
00004c  4601              MOV      r1,r0
00004e  a014              ADR      r0,|L19.160|
000050  f7fffffe          BL       __2printf
;;;691    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000054  f7fffffe          BL       CLK_GetLXTFreq
000058  4601              MOV      r1,r0
00005a  a017              ADR      r0,|L19.184|
00005c  f7fffffe          BL       __2printf
;;;692    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000060  f7fffffe          BL       CLK_GetPCLK0Freq
000064  4601              MOV      r1,r0
000066  a01a              ADR      r0,|L19.208|
000068  f7fffffe          BL       __2printf
;;;693    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());	
00006c  f7fffffe          BL       CLK_GetPCLK1Freq
000070  4601              MOV      r1,r0
000072  e8bd4010          POP      {r4,lr}
000076  a01d              ADR      r0,|L19.236|
000078  f7ffbffe          B.W      __2printf
;;;694    
;;;695    //    printf("Product ID 0x%8X\n", SYS->PDID);
;;;696    	
;;;697    	#endif
;;;698    }
;;;699    
                          ENDP

                  |L19.124|
                          DCD      0x04000010
                  |L19.128|
                          DCD      0x40070000
                  |L19.132|
000084  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000088  4b5f4765
00008c  74435055
000090  46726571
000094  203a2025
000098  38640d0a
00009c  00      
00009d  00                DCB      0
00009e  00                DCB      0
00009f  00                DCB      0
                  |L19.160|
0000a0  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
0000a4  47657448
0000a8  58544672
0000ac  6571203a
0000b0  20253864
0000b4  0d0a00  
0000b7  00                DCB      0
                  |L19.184|
0000b8  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000bc  4765744c
0000c0  58544672
0000c4  6571203a
0000c8  20253864
0000cc  0d0a00  
0000cf  00                DCB      0
                  |L19.208|
0000d0  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000d4  47657450
0000d8  434c4b30
0000dc  46726571
0000e0  203a2025
0000e4  38640d0a
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L19.236|
0000ec  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000f0  47657450
0000f4  434c4b31
0000f8  46726571
0000fc  203a2025
000100  38640d0a
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0

                          AREA ||i.UARTx_Process||, CODE, READONLY, ALIGN=2

                  UARTx_Process PROC
;;;625    
;;;626    void UARTx_Process(void)
000000  4811              LDR      r0,|L20.72|
;;;627    {
;;;628    	uint8_t res = 0;
;;;629    	res = UART_READ(UART0);
000002  6800              LDR      r0,[r0,#0]
000004  b2c0              UXTB     r0,r0
;;;630    
;;;631    	if (res > 0x7F)
000006  287f              CMP      r0,#0x7f
000008  d902              BLS      |L20.16|
;;;632    	{
;;;633    		printf("invalid command\r\n");
00000a  a010              ADR      r0,|L20.76|
00000c  f7ffbffe          B.W      __2printf
                  |L20.16|
;;;634    	}
;;;635    	else
;;;636    	{
;;;637    		switch(res)
000010  285a              CMP      r0,#0x5a
000012  d009              BEQ      |L20.40|
000014  dc04              BGT      |L20.32|
000016  2831              CMP      r0,#0x31
000018  d013              BEQ      |L20.66|
00001a  2858              CMP      r0,#0x58
00001c  d113              BNE      |L20.70|
00001e  e003              B        |L20.40|
                  |L20.32|
000020  2878              CMP      r0,#0x78
000022  d001              BEQ      |L20.40|
000024  287a              CMP      r0,#0x7a
000026  d10e              BNE      |L20.70|
                  |L20.40|
000028  f3bf8f4f          DSB      
00002c  480c              LDR      r0,|L20.96|
00002e  6801              LDR      r1,[r0,#0]
000030  4a0c              LDR      r2,|L20.100|
000032  f40161e0          AND      r1,r1,#0x700
000036  4311              ORRS     r1,r1,r2
000038  6001              STR      r1,[r0,#0]
00003a  f3bf8f4f          DSB      
                  |L20.62|
00003e  bf00              NOP      
000040  e7fd              B        |L20.62|
                  |L20.66|
;;;638    		{
;;;639    			case '1':
;;;640    				generate_random_SPI_TX_data();
000042  f7ffbffe          B.W      generate_random_SPI_TX_data
                  |L20.70|
;;;641    				break;
;;;642    
;;;643    			case 'X':
;;;644    			case 'x':
;;;645    			case 'Z':
;;;646    			case 'z':
;;;647    				NVIC_SystemReset();		
;;;648    				break;
;;;649    		}
;;;650    	}
;;;651    }
000046  4770              BX       lr
;;;652    
                          ENDP

                  |L20.72|
                          DCD      0x40070000
                  |L20.76|
00004c  696e7661          DCB      "invalid command\r\n",0
000050  6c696420
000054  636f6d6d
000058  616e640d
00005c  0a00    
00005e  00                DCB      0
00005f  00                DCB      0
                  |L20.96|
                          DCD      0xe000ed0c
                  |L20.100|
                          DCD      0x05fa0004

                          AREA ||i.compare_buffer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  compare_buffer PROC
;;;148    
;;;149    void compare_buffer(uint8_t *src, uint8_t *des, int nBytes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;150    {
000004  4616              MOV      r6,r2
000006  460f              MOV      r7,r1
000008  4680              MOV      r8,r0
;;;151        uint16_t i = 0;	
00000a  2400              MOVS     r4,#0
;;;152    	
;;;153        for (i = 0; i < nBytes; i++)
;;;154        {
;;;155            if (src[i] != des[i])
;;;156            {
;;;157                printf("error idx : %4d : 0x%2X , 0x%2X\r\n", i , src[i],des[i]);
;;;158    			set_flag(flag_error , ENABLE);
00000c  4d0f              LDR      r5,|L21.76|
00000e  e00e              B        |L21.46|
                  |L21.16|
000010  f8182004          LDRB     r2,[r8,r4]            ;155
000014  5d3b              LDRB     r3,[r7,r4]            ;155
000016  429a              CMP      r2,r3                 ;155
000018  d007              BEQ      |L21.42|
00001a  4621              MOV      r1,r4                 ;157
00001c  a00c              ADR      r0,|L21.80|
00001e  f7fffffe          BL       __2printf
000022  68e8              LDR      r0,[r5,#0xc]  ; BitFlag
000024  f0400008          ORR      r0,r0,#8
000028  60e8              STR      r0,[r5,#0xc]  ; BitFlag
                  |L21.42|
00002a  1c64              ADDS     r4,r4,#1
00002c  b2a4              UXTH     r4,r4                 ;153
                  |L21.46|
00002e  42b4              CMP      r4,r6                 ;153
000030  dbee              BLT      |L21.16|
;;;159            }
;;;160        }
;;;161    
;;;162    	if (!is_flag_set(flag_error))
000032  68e8              LDR      r0,[r5,#0xc]  ; BitFlag
000034  0700              LSLS     r0,r0,#28
000036  d407              BMI      |L21.72|
;;;163    	{
;;;164        	printf("%s finish \r\n" , __FUNCTION__);	
000038  490e              LDR      r1,|L21.116|
00003a  a00f              ADR      r0,|L21.120|
00003c  f7fffffe          BL       __2printf
;;;165    		set_flag(flag_error , DISABLE);
000040  68e8              LDR      r0,[r5,#0xc]  ; BitFlag
000042  f0200008          BIC      r0,r0,#8
000046  60e8              STR      r0,[r5,#0xc]  ; BitFlag
                  |L21.72|
;;;166    	}
;;;167    
;;;168    }
000048  e8bd81f0          POP      {r4-r8,pc}
;;;169    
                          ENDP

                  |L21.76|
                          DCD      ||.data||
                  |L21.80|
000050  6572726f          DCB      "error idx : %4d : 0x%2X , 0x%2X\r\n",0
000054  72206964
000058  78203a20
00005c  25346420
000060  3a203078
000064  25325820
000068  2c203078
00006c  2532580d
000070  0a00    
000072  00                DCB      0
000073  00                DCB      0
                  |L21.116|
                          DCD      ||.constdata||+0x100
                  |L21.120|
000078  25732066          DCB      "%s finish \r\n",0
00007c  696e6973
000080  68200d0a
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||i.copy_buffer||, CODE, READONLY, ALIGN=1

                  copy_buffer PROC
;;;185    
;;;186    void copy_buffer(void *dest, void *src, unsigned int size)
000000  b510              PUSH     {r4,lr}
;;;187    {
;;;188        uint8_t *pu8Src, *pu8Dest;
;;;189        unsigned int i;
;;;190        
;;;191        pu8Dest = (uint8_t *)dest;
;;;192        pu8Src  = (uint8_t *)src;
;;;193    
;;;194    
;;;195    	#if 0
;;;196    	  while (size--)
;;;197    	    *pu8Dest++ = *pu8Src++;
;;;198    	#else
;;;199        for (i = 0; i < size; i++)
000002  2300              MOVS     r3,#0
000004  e002              B        |L22.12|
                  |L22.6|
;;;200            pu8Dest[i] = pu8Src[i];
000006  5ccc              LDRB     r4,[r1,r3]
000008  54c4              STRB     r4,[r0,r3]
00000a  1c5b              ADDS     r3,r3,#1
                  |L22.12|
00000c  4293              CMP      r3,r2                 ;199
00000e  d3fa              BCC      |L22.6|
;;;201    	#endif
;;;202    }
000010  bd10              POP      {r4,pc}
;;;203    
                          ENDP


                          AREA ||i.dump_buffer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  dump_buffer PROC
;;;203    
;;;204    void dump_buffer(uint8_t *pucBuff, int nBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;205    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;206        uint16_t i = 0;
000006  2400              MOVS     r4,#0
;;;207        
;;;208        printf("dump_buffer : %2d\r\n" , nBytes);    
000008  a00b              ADR      r0,|L23.56|
00000a  f7fffffe          BL       __2printf
;;;209        for (i = 0 ; i < nBytes ; i++)
00000e  e00c              B        |L23.42|
                  |L23.16|
;;;210        {
;;;211            printf("0x%2X," , pucBuff[i]);
000010  5d31              LDRB     r1,[r6,r4]
000012  a00e              ADR      r0,|L23.76|
000014  f7fffffe          BL       __2printf
;;;212            if ((i+1)%8 ==0)
000018  0760              LSLS     r0,r4,#29
00001a  f1b04f60          CMP      r0,#0xe0000000
00001e  d102              BNE      |L23.38|
;;;213            {
;;;214                printf("\r\n");
000020  a00c              ADR      r0,|L23.84|
000022  f7fffffe          BL       __2printf
                  |L23.38|
000026  1c64              ADDS     r4,r4,#1
000028  b2a4              UXTH     r4,r4                 ;209
                  |L23.42|
00002a  42ac              CMP      r4,r5                 ;209
00002c  dbf0              BLT      |L23.16|
;;;215            }            
;;;216        }
;;;217        printf("\r\n\r\n");
00002e  e8bd4070          POP      {r4-r6,lr}
000032  a009              ADR      r0,|L23.88|
000034  f7ffbffe          B.W      __2printf
;;;218    }
;;;219    
                          ENDP

                  |L23.56|
000038  64756d70          DCB      "dump_buffer : %2d\r\n",0
00003c  5f627566
000040  66657220
000044  3a202532
000048  640d0a00
                  |L23.76|
00004c  30782532          DCB      "0x%2X,",0
000050  582c00  
000053  00                DCB      0
                  |L23.84|
000054  0d0a00            DCB      "\r\n",0
000057  00                DCB      0
                  |L23.88|
000058  0d0a0d0a          DCB      "\r\n\r\n",0
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.dump_buffer_hex||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                  dump_buffer_hex PROC
;;;219    
;;;220    void dump_buffer_hex(uint8_t *pucBuff, int nBytes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;221    {
000004  460e              MOV      r6,r1
000006  4607              MOV      r7,r0
;;;222        int     nIdx, i;
;;;223    
;;;224        nIdx = 0;
000008  2500              MOVS     r5,#0
00000a  e025              B        |L24.88|
                  |L24.12|
;;;225        while (nBytes > 0)
;;;226        {
;;;227            printf("0x%04X  ", nIdx);
00000c  4629              MOV      r1,r5
00000e  a016              ADR      r0,|L24.104|
000010  f7fffffe          BL       __2printf
;;;228            for (i = 0; i < 16; i++)
000014  2400              MOVS     r4,#0
                  |L24.22|
;;;229                printf("%02X ", pucBuff[nIdx + i]);
000016  1928              ADDS     r0,r5,r4
000018  5c39              LDRB     r1,[r7,r0]
00001a  a016              ADR      r0,|L24.116|
00001c  f7fffffe          BL       __2printf
000020  1c64              ADDS     r4,r4,#1
000022  2c10              CMP      r4,#0x10              ;228
000024  dbf7              BLT      |L24.22|
;;;230            printf("  ");
000026  a015              ADR      r0,|L24.124|
000028  f7fffffe          BL       __2printf
;;;231            for (i = 0; i < 16; i++)
00002c  2400              MOVS     r4,#0
                  |L24.46|
;;;232            {
;;;233                if ((pucBuff[nIdx + i] >= 0x20) && (pucBuff[nIdx + i] < 127))
00002e  1928              ADDS     r0,r5,r4
000030  5c39              LDRB     r1,[r7,r0]
000032  f1a10020          SUB      r0,r1,#0x20
000036  285f              CMP      r0,#0x5f
000038  d203              BCS      |L24.66|
;;;234                    printf("%c", pucBuff[nIdx + i]);
00003a  a011              ADR      r0,|L24.128|
00003c  f7fffffe          BL       __2printf
000040  e002              B        |L24.72|
                  |L24.66|
;;;235                else
;;;236                    printf(".");
000042  a010              ADR      r0,|L24.132|
000044  f7fffffe          BL       __2printf
                  |L24.72|
000048  1c64              ADDS     r4,r4,#1
00004a  1e76              SUBS     r6,r6,#1
00004c  2c10              CMP      r4,#0x10              ;231
00004e  dbee              BLT      |L24.46|
;;;237                nBytes--;
;;;238            }
;;;239            nIdx += 16;
;;;240            printf("\n");
000050  a00d              ADR      r0,|L24.136|
000052  3510              ADDS     r5,r5,#0x10
000054  f7fffffe          BL       __2printf
                  |L24.88|
000058  2e00              CMP      r6,#0                 ;225
00005a  dcd7              BGT      |L24.12|
;;;241        }
;;;242        printf("\n");
00005c  e8bd41f0          POP      {r4-r8,lr}
000060  a009              ADR      r0,|L24.136|
000062  f7ffbffe          B.W      __2printf
;;;243    }
;;;244    
                          ENDP

000066  0000              DCW      0x0000
                  |L24.104|
000068  30782530          DCB      "0x%04X  ",0
00006c  34582020
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0
                  |L24.116|
000074  25303258          DCB      "%02X ",0
000078  2000    
00007a  00                DCB      0
00007b  00                DCB      0
                  |L24.124|
00007c  202000            DCB      "  ",0
00007f  00                DCB      0
                  |L24.128|
000080  256300            DCB      "%c",0
000083  00                DCB      0
                  |L24.132|
000084  2e00              DCB      ".",0
000086  00                DCB      0
000087  00                DCB      0
                  |L24.136|
000088  0a00              DCB      "\n",0
00008a  00                DCB      0
00008b  00                DCB      0

                          AREA ||i.generate_random_SPI_TX_data||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                  generate_random_SPI_TX_data PROC
;;;540    */
;;;541    void generate_random_SPI_TX_data(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;542    {	
;;;543    	uint8_t datalen = 0;
;;;544    	uint8_t i = 0;
000002  2400              MOVS     r4,#0
;;;545    	uint8_t checksum = 0;
;;;546    	uint8_t packetsize = 0;
;;;547    
;;;548    	uint8_t head_byte = 1;
000004  2701              MOVS     r7,#1
;;;549    	uint8_t length_byte = 1;
000006  463e              MOV      r6,r7
;;;550    
;;;551    	reset_buffer(g_au8MasterToSlaveTestPattern , 0x00, SPI_DATA_NUM);
000008  2240              MOVS     r2,#0x40
00000a  4621              MOV      r1,r4
00000c  4818              LDR      r0,|L25.112|
00000e  f7fffffe          BL       reset_buffer
;;;552    
;;;553    	datalen = random(1 , SPI_DATA_NUM-4);	// buffer length is 64  , exclude head/length/checksum/tail
000012  213c              MOVS     r1,#0x3c
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       random
00001a  b2c5              UXTB     r5,r0
00001c  4814              LDR      r0,|L25.112|
;;;554    
;;;555    	for (i = 0 ; i < datalen  ; i++)
00001e  e003              B        |L25.40|
                  |L25.32|
;;;556    	{
;;;557    		g_au8MasterToSlaveTestPattern[i+2] = i;
000020  1901              ADDS     r1,r0,r4
000022  708c              STRB     r4,[r1,#2]
000024  1c64              ADDS     r4,r4,#1
000026  b2e4              UXTB     r4,r4                 ;555
                  |L25.40|
000028  42ac              CMP      r4,r5                 ;555
00002a  d3f9              BCC      |L25.32|
;;;558    	}
;;;559    
;;;560    	checksum = CRC8( (uint8_t *) &g_au8MasterToSlaveTestPattern[2] , datalen+(head_byte+length_byte) );
00002c  19b9              ADDS     r1,r7,r6
00002e  4604              MOV      r4,r0
000030  4429              ADD      r1,r1,r5
000032  1c80              ADDS     r0,r0,#2
000034  f7fffffe          BL       CRC8
000038  4601              MOV      r1,r0
;;;561    
;;;562    	g_au8MasterToSlaveTestPattern[0] = 0x5A;
00003a  205a              MOVS     r0,#0x5a
00003c  7020              STRB     r0,[r4,#0]
;;;563    	g_au8MasterToSlaveTestPattern[1] = datalen;	
;;;564    	g_au8MasterToSlaveTestPattern[datalen+2] = checksum;	
00003e  1960              ADDS     r0,r4,r5
000040  7065              STRB     r5,[r4,#1]            ;563
000042  7081              STRB     r1,[r0,#2]
;;;565    	g_au8MasterToSlaveTestPattern[datalen+3] = 0xA5;
000044  22a5              MOVS     r2,#0xa5
000046  70c2              STRB     r2,[r0,#3]
;;;566    	packetsize = datalen + 4;	//head/length/checksum/tail
000048  1d28              ADDS     r0,r5,#4
00004a  b2c4              UXTB     r4,r0
;;;567    
;;;568    	#if 1	// debug
;;;569    	printf("SPI TX = (data len:0x%2X/%2d ,packet len:0x%2X,checksum :0x%2X)\r\n" ,datalen,datalen,packetsize,checksum);
00004c  462a              MOV      r2,r5
00004e  9100              STR      r1,[sp,#0]
000050  4623              MOV      r3,r4
000052  4611              MOV      r1,r2
000054  4807              LDR      r0,|L25.116|
000056  f7fffffe          BL       __2printf
;;;570    	dump_buffer_hex(g_au8MasterToSlaveTestPattern , packetsize);
00005a  4621              MOV      r1,r4
00005c  4804              LDR      r0,|L25.112|
00005e  f7fffffe          BL       dump_buffer_hex
;;;571    	#endif
;;;572    
;;;573    	SPI_Master_TX(MasterSpiPortNum , g_au8MasterToSlaveTestPattern,packetsize);
000062  4622              MOV      r2,r4
000064  e8bd40f8          POP      {r3-r7,lr}
000068  4901              LDR      r1,|L25.112|
00006a  4803              LDR      r0,|L25.120|
00006c  f7ffbffe          B.W      SPI_Master_TX
;;;574    
;;;575    }
;;;576    
                          ENDP

                  |L25.112|
                          DCD      ||.bss||
                  |L25.116|
                          DCD      ||.conststring||
                  |L25.120|
                          DCD      0x40062000

                          AREA ||i.get_tick||, CODE, READONLY, ALIGN=2

                  get_tick PROC
;;;138    
;;;139    uint32_t get_tick(void)
000000  4801              LDR      r0,|L26.8|
;;;140    {
;;;141    	return (counter_tick);
000002  6900              LDR      r0,[r0,#0x10]  ; counter_tick
;;;142    }
000004  4770              BX       lr
;;;143    
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      ||.data||

                          AREA ||i.loop||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                  loop PROC
;;;576    
;;;577    void loop(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;578    {
;;;579    	if (is_flag_set(flag_SPI_Slave_RX))
000002  4c12              LDR      r4,|L27.76|
000004  68e0              LDR      r0,[r4,#0xc]  ; BitFlag
000006  0740              LSLS     r0,r0,#29
000008  d51e              BPL      |L27.72|
;;;580    	{
;;;581    		set_flag(flag_SPI_Slave_RX ,DISABLE);
00000a  68e0              LDR      r0,[r4,#0xc]  ; BitFlag
00000c  f0200004          BIC      r0,r0,#4
000010  60e0              STR      r0,[r4,#0xc]  ; BitFlag
;;;582    
;;;583    		#if 1	// debug
;;;584    		printf("SPI RX = (data len:0x%2X/%2d(%2d),packet len:0x%2X,checksum :0x%2X)\r\n" ,packetlen-4,packetlen-4,g_au8SlaveRxBuffer[1],packetlen,g_au8SlaveRxBuffer[packetlen-2]);
000012  480f              LDR      r0,|L27.80|
000014  8821              LDRH     r1,[r4,#0]  ; packetlen
000016  1842              ADDS     r2,r0,r1
000018  f8122c02          LDRB     r2,[r2,#-2]
00001c  e9cd1200          STRD     r1,r2,[sp,#0]
000020  7843              LDRB     r3,[r0,#1]  ; g_au8SlaveRxBuffer
000022  1f0a              SUBS     r2,r1,#4
000024  480b              LDR      r0,|L27.84|
000026  1f09              SUBS     r1,r1,#4
000028  f7fffffe          BL       __2printf
;;;585    		dump_buffer_hex(g_au8SlaveRxBuffer , packetlen);
00002c  8821              LDRH     r1,[r4,#0]  ; packetlen
00002e  4808              LDR      r0,|L27.80|
000030  f7fffffe          BL       dump_buffer_hex
;;;586    		#endif
;;;587    
;;;588    		compare_buffer(g_au8MasterToSlaveTestPattern,g_au8SlaveRxBuffer,packetlen);
000034  4906              LDR      r1,|L27.80|
000036  8822              LDRH     r2,[r4,#0]  ; packetlen
000038  f1a10040          SUB      r0,r1,#0x40
00003c  f7fffffe          BL       compare_buffer
;;;589    		
;;;590    		SPI_Slave_Rx_PDMA_Enable();	
000040  e8bd401c          POP      {r2-r4,lr}
000044  f7ffbffe          B.W      SPI_Slave_Rx_PDMA_Enable
                  |L27.72|
;;;591    	}
;;;592    
;;;593    }
000048  bd1c              POP      {r2-r4,pc}
;;;594    
                          ENDP

00004a  0000              DCW      0x0000
                  |L27.76|
                          DCD      ||.data||
                  |L27.80|
                          DCD      ||.bss||+0x40
                  |L27.84|
                          DCD      ||.conststring||+0x44

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;818    
;;;819    int main()
000000  f7fffffe          BL       SYS_Init
;;;820    {
;;;821        SYS_Init();
;;;822    
;;;823    	UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;824    	Custom_Init();	
000008  f7fffffe          BL       Custom_Init
;;;825    	TIMER1_Init();
00000c  f7fffffe          BL       TIMER1_Init
;;;826    
;;;827    	ADC_InitChannel(ADC0_CH14); 
000010  200e              MOVS     r0,#0xe
000012  f7fffffe          BL       ADC_InitChannel
;;;828        prepare_seed();  
000016  f7fffffe          BL       prepare_seed
;;;829    
;;;830    	SPI_Master_Init();
00001a  f7fffffe          BL       SPI_Master_Init
;;;831    
;;;832    	SPI_Slave_Init();
00001e  f7fffffe          BL       SPI_Slave_Init
;;;833    	SPI_Slave_Rx_PDMA_Init();
000022  f7fffffe          BL       SPI_Slave_Rx_PDMA_Init
                  |L28.38|
;;;834    
;;;835        /* Got no where to go, just loop forever */
;;;836        while(1)
;;;837        {
;;;838    		loop();
000026  f7fffffe          BL       loop
00002a  e7fc              B        |L28.38|
;;;839    
;;;840        }
;;;841    }
;;;842    
                          ENDP


                          AREA ||i.prepare_seed||, CODE, READONLY, ALIGN=2

                  prepare_seed PROC
;;;334    
;;;335    void prepare_seed(void)
000000  b510              PUSH     {r4,lr}
;;;336    {
;;;337        za = ADC_ReadChannel(); 
000002  f7fffffe          BL       ADC_ReadChannel
000006  4c06              LDR      r4,|L29.32|
000008  8060              STRH     r0,[r4,#2]
;;;338        zb = ADC_ReadChannel(); 
00000a  f7fffffe          BL       ADC_ReadChannel
00000e  80a0              STRH     r0,[r4,#4]
;;;339        zc = ADC_ReadChannel(); 
000010  f7fffffe          BL       ADC_ReadChannel
000014  80e0              STRH     r0,[r4,#6]
;;;340        zx = ADC_ReadChannel();     
000016  f7fffffe          BL       ADC_ReadChannel
00001a  8120              STRH     r0,[r4,#8]
;;;341    }
00001c  bd10              POP      {r4,pc}
;;;342    
                          ENDP

00001e  0000              DCW      0x0000
                  |L29.32|
                          DCD      ||.data||

                          AREA ||i.random||, CODE, READONLY, ALIGN=1

                  random PROC
;;;342    
;;;343    uint32_t random(int min, int max)
000000  b570              PUSH     {r4-r6,lr}
;;;344    {
000002  4605              MOV      r5,r0
;;;345        uint32_t res= 0;    
;;;346        uint32_t length_of_range = 0;
;;;347        uint16_t adc_vaule = 0;
;;;348        uint16_t seed = 0;
;;;349    
;;;350        length_of_range = max - min + 1;
000004  1b4c              SUBS     r4,r1,r5
000006  1c64              ADDS     r4,r4,#1
;;;351    
;;;352        adc_vaule = ADC_ReadChannel(); 
000008  f7fffffe          BL       ADC_ReadChannel
00000c  b286              UXTH     r6,r0
;;;353        seed = rng();
00000e  f7fffffe          BL       ||rng||
;;;354        srand(seed + adc_vaule);
000012  4430              ADD      r0,r0,r6
000014  f7fffffe          BL       srand
;;;355    
;;;356        res = (uint32_t)(rand() % length_of_range + min);
000018  f7fffffe          BL       rand
00001c  fbb0f1f4          UDIV     r1,r0,r4
000020  fb040011          MLS      r0,r4,r1,r0
000024  4428              ADD      r0,r0,r5
;;;357    
;;;358        #if 0   // debug
;;;359        printf("adc_vaule:0x%4X,res:%5d(min:%5d,max:%5d) [0x%4X/0x%4X/0x%4X/0x%4X/0x%4X]\r\n" ,
;;;360                adc_vaule , res , min , max , 
;;;361                za , zb ,zc , zx , seed);
;;;362        #endif
;;;363    
;;;364        return res;
;;;365    }
000026  bd70              POP      {r4-r6,pc}
;;;366    
                          ENDP


                          AREA ||i.reset_buffer||, CODE, READONLY, ALIGN=1

                  reset_buffer PROC
;;;169    
;;;170    void reset_buffer(void *dest, unsigned int val, unsigned int size)
000000  b2c9              UXTB     r1,r1
;;;171    {
000002  e001              B        |L31.8|
                  |L31.4|
;;;172        uint8_t *pu8Dest;
;;;173    //    unsigned int i;
;;;174        
;;;175        pu8Dest = (uint8_t *)dest;
;;;176    
;;;177    	#if 1
;;;178    	while (size-- > 0)
;;;179    		*pu8Dest++ = val;
000004  f8001b01          STRB     r1,[r0],#1
                  |L31.8|
000008  1e52              SUBS     r2,r2,#1
00000a  d2fb              BCS      |L31.4|
;;;180    	#else
;;;181    	memset(pu8Dest, val, size * (sizeof(pu8Dest[0]) ));
;;;182    	#endif
;;;183    	
;;;184    }
00000c  4770              BX       lr
;;;185    
                          ENDP


                          AREA ||i.rng||, CODE, READONLY, ALIGN=2

                  ||rng|| PROC
;;;325    // Fast 0-255 random number generator from http://eternityforest.com/Projects/rng.php:
;;;326    uint16_t rng(void)//void uint8_t __attribute__((always_inline)) rng(void)
000000  4909              LDR      r1,|L32.40|
;;;327    {
;;;328        zx++;
000002  890a              LDRH     r2,[r1,#8]  ; zx
000004  1c52              ADDS     r2,r2,#1
000006  810a              STRH     r2,[r1,#8]
;;;329        za = (za^zc^zx);
000008  8848              LDRH     r0,[r1,#2]  ; za
00000a  88cb              LDRH     r3,[r1,#6]  ; zc
00000c  4058              EORS     r0,r0,r3
00000e  4050              EORS     r0,r0,r2
000010  8048              STRH     r0,[r1,#2]
;;;330        zb = (zb+za);
000012  888a              LDRH     r2,[r1,#4]  ; zb
000014  4402              ADD      r2,r2,r0
000016  b292              UXTH     r2,r2
000018  808a              STRH     r2,[r1,#4]
;;;331        zc = (zc+(zb>>1)^za);
00001a  eb030252          ADD      r2,r3,r2,LSR #1
00001e  4042              EORS     r2,r2,r0
000020  b290              UXTH     r0,r2
000022  80c8              STRH     r0,[r1,#6]
;;;332        return zc;
;;;333    }
000024  4770              BX       lr
;;;334    
                          ENDP

000026  0000              DCW      0x0000
                  |L32.40|
                          DCD      ||.data||

                          AREA ||i.set_tick||, CODE, READONLY, ALIGN=2

                  set_tick PROC
;;;143    
;;;144    void set_tick(uint32_t t)
000000  4901              LDR      r1,|L33.8|
;;;145    {
;;;146    	counter_tick = t;
000002  6108              STR      r0,[r1,#0x10]  ; counter_tick
;;;147    }
000004  4770              BX       lr
;;;148    
                          ENDP

000006  0000              DCW      0x0000
                  |L33.8|
                          DCD      ||.data||

                          AREA ||i.tick_counter||, CODE, READONLY, ALIGN=2

                  tick_counter PROC
;;;133    
;;;134    void tick_counter(void)
000000  4802              LDR      r0,|L34.12|
;;;135    {
;;;136    	counter_tick++;
000002  6901              LDR      r1,[r0,#0x10]  ; counter_tick
000004  1c49              ADDS     r1,r1,#1
000006  6101              STR      r1,[r0,#0x10]  ; counter_tick
;;;137    }
000008  4770              BX       lr
;;;138    
                          ENDP

00000a  0000              DCW      0x0000
                  |L34.12|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_au8MasterToSlaveTestPattern
                          %        64
                  g_au8SlaveRxBuffer
                          %        64

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  CRC8TAB
000000  00316253          DCB      0x00,0x31,0x62,0x53
000004  c4f5a697          DCB      0xc4,0xf5,0xa6,0x97
000008  b988dbea          DCB      0xb9,0x88,0xdb,0xea
00000c  7d4c1f2e          DCB      0x7d,0x4c,0x1f,0x2e
000010  43722110          DCB      0x43,0x72,0x21,0x10
000014  87b6e5d4          DCB      0x87,0xb6,0xe5,0xd4
000018  facb98a9          DCB      0xfa,0xcb,0x98,0xa9
00001c  3e0f5c6d          DCB      0x3e,0x0f,0x5c,0x6d
000020  86b7e4d5          DCB      0x86,0xb7,0xe4,0xd5
000024  42732011          DCB      0x42,0x73,0x20,0x11
000028  3f0e5d6c          DCB      0x3f,0x0e,0x5d,0x6c
00002c  fbca99a8          DCB      0xfb,0xca,0x99,0xa8
000030  c5f4a796          DCB      0xc5,0xf4,0xa7,0x96
000034  01306352          DCB      0x01,0x30,0x63,0x52
000038  7c4d1e2f          DCB      0x7c,0x4d,0x1e,0x2f
00003c  b889daeb          DCB      0xb8,0x89,0xda,0xeb
000040  3d0c5f6e          DCB      0x3d,0x0c,0x5f,0x6e
000044  f9c89baa          DCB      0xf9,0xc8,0x9b,0xaa
000048  84b5e6d7          DCB      0x84,0xb5,0xe6,0xd7
00004c  40712213          DCB      0x40,0x71,0x22,0x13
000050  7e4f1c2d          DCB      0x7e,0x4f,0x1c,0x2d
000054  ba8bd8e9          DCB      0xba,0x8b,0xd8,0xe9
000058  c7f6a594          DCB      0xc7,0xf6,0xa5,0x94
00005c  03326150          DCB      0x03,0x32,0x61,0x50
000060  bb8ad9e8          DCB      0xbb,0x8a,0xd9,0xe8
000064  7f4e1d2c          DCB      0x7f,0x4e,0x1d,0x2c
000068  02336051          DCB      0x02,0x33,0x60,0x51
00006c  c6f7a495          DCB      0xc6,0xf7,0xa4,0x95
000070  f8c99aab          DCB      0xf8,0xc9,0x9a,0xab
000074  3c0d5e6f          DCB      0x3c,0x0d,0x5e,0x6f
000078  41702312          DCB      0x41,0x70,0x23,0x12
00007c  85b4e7d6          DCB      0x85,0xb4,0xe7,0xd6
000080  7a4b1829          DCB      0x7a,0x4b,0x18,0x29
000084  be8fdced          DCB      0xbe,0x8f,0xdc,0xed
000088  c3f2a190          DCB      0xc3,0xf2,0xa1,0x90
00008c  07366554          DCB      0x07,0x36,0x65,0x54
000090  39085b6a          DCB      0x39,0x08,0x5b,0x6a
000094  fdcc9fae          DCB      0xfd,0xcc,0x9f,0xae
000098  80b1e2d3          DCB      0x80,0xb1,0xe2,0xd3
00009c  44752617          DCB      0x44,0x75,0x26,0x17
0000a0  fccd9eaf          DCB      0xfc,0xcd,0x9e,0xaf
0000a4  38095a6b          DCB      0x38,0x09,0x5a,0x6b
0000a8  45742716          DCB      0x45,0x74,0x27,0x16
0000ac  81b0e3d2          DCB      0x81,0xb0,0xe3,0xd2
0000b0  bf8eddec          DCB      0xbf,0x8e,0xdd,0xec
0000b4  7b4a1928          DCB      0x7b,0x4a,0x19,0x28
0000b8  06376455          DCB      0x06,0x37,0x64,0x55
0000bc  c2f3a091          DCB      0xc2,0xf3,0xa0,0x91
0000c0  47762514          DCB      0x47,0x76,0x25,0x14
0000c4  83b2e1d0          DCB      0x83,0xb2,0xe1,0xd0
0000c8  fecf9cad          DCB      0xfe,0xcf,0x9c,0xad
0000cc  3a0b5869          DCB      0x3a,0x0b,0x58,0x69
0000d0  04356657          DCB      0x04,0x35,0x66,0x57
0000d4  c0f1a293          DCB      0xc0,0xf1,0xa2,0x93
0000d8  bd8cdffe          DCB      0xbd,0x8c,0xdf,0xfe
0000dc  79481b2a          DCB      0x79,0x48,0x1b,0x2a
0000e0  c1f0a392          DCB      0xc1,0xf0,0xa3,0x92
0000e4  05346756          DCB      0x05,0x34,0x67,0x56
0000e8  78491a2b          DCB      0x78,0x49,0x1a,0x2b
0000ec  bc8ddeef          DCB      0xbc,0x8d,0xde,0xef
0000f0  82b3e0d1          DCB      0x82,0xb3,0xe0,0xd1
0000f4  46772415          DCB      0x46,0x77,0x24,0x15
0000f8  3b0a5968          DCB      0x3b,0x0a,0x59,0x68
0000fc  ffce9dac          DCB      0xff,0xce,0x9d,0xac
                  __FUNCTION__
000100  636f6d70          DCB      0x63,0x6f,0x6d,0x70
000104  6172655f          DCB      0x61,0x72,0x65,0x5f
000108  62756666          DCB      0x62,0x75,0x66,0x66
00010c  657200            DCB      0x65,0x72,0x00

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  53504920          DCB      "SPI TX = (data len:0x%2X/%2d ,packet len:0x%2X,checksum"
000004  5458203d
000008  20286461
00000c  7461206c
000010  656e3a30
000014  78253258
000018  2f253264
00001c  202c7061
000020  636b6574
000024  206c656e
000028  3a307825
00002c  32582c63
000030  6865636b
000034  73756d  
000037  203a3078          DCB      " :0x%2X)\r\n",0
00003b  25325829
00003f  0d0a00  
000042  00                DCB      0
000043  00                DCB      0
000044  53504920          DCB      "SPI RX = (data len:0x%2X/%2d(%2d),packet len:0x%2X,chec"
000048  5258203d
00004c  20286461
000050  7461206c
000054  656e3a30
000058  78253258
00005c  2f253264
000060  28253264
000064  292c7061
000068  636b6574
00006c  206c656e
000070  3a307825
000074  32582c63
000078  686563  
00007b  6b73756d          DCB      "ksum :0x%2X)\r\n",0
00007f  203a3078
000083  25325829
000087  0d0a00  

                          AREA ||.data||, DATA, ALIGN=2

                  packetlen
000000  0000              DCW      0x0000
                  ||za||
000002  0000              DCW      0x0000
                  ||zb||
000004  0000              DCW      0x0000
                  ||zc||
000006  0000              DCW      0x0000
                  ||zx||
000008  0000              DCW      0x0000
00000a  0000              DCB      0x00,0x00
                  BitFlag
                          DCD      0x00000000
                  counter_tick
                          DCD      0x00000000

                          AREA ||area_number.41||, DATA, ALIGN=0

                          EXPORTAS ||area_number.41||, ||.data||
                  ADC_CH_TypeDef
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_BitFlag____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REVSH|
#line 402
|__asm___6_main_c_BitFlag____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____RRX|
#line 587
|__asm___6_main_c_BitFlag____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
